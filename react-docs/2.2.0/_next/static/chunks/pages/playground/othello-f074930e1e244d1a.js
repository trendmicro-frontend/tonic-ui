(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6574],{57694:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return k}});var l=t(52322),r=t(45392),o=t(96835),a=t(49857),i=t(73645),c=t(70758),s=t(2784),u=(0,s.createContext)(),h=function(e,n,t){return e[n+8*t]},d=function(e,n,t,l){if(0!==h(e,t,l))return[];var r=[],o=[],a=function(t,l){var a=h(e,t,l);return 0!==a&&(a!==n?(o.push(t+8*l),!0):a!==n||(r.push.apply(r,o),!1))};o.length=0;for(var i=t-1;i>=0&&!1!==a(i,l);i--);o.length=0;for(var c=t+1;c<8&&!1!==a(c,l);c++);o.length=0;for(var s=l-1;s>=0&&!1!==a(t,s);s--);o.length=0;for(var u=l+1;u<8&&!1!==a(t,u);u++);o.length=0;for(var d=t-1,p=l-1;d>=0&&p>=0&&!1!==a(d,p);d--,p--);o.length=0;for(var f=t+1,m=l-1;f<8&&m>=0&&!1!==a(f,m);f++,m--);o.length=0;for(var g=t+1,E=l+1;g<8&&E<8&&!1!==a(g,E);g++,E++);o.length=0;for(var x=t-1,b=l+1;x>=0&&b<8&&!1!==a(x,b);x--,b++);return r},p=function(e,n){for(var t=[],l=0;l<64;l++)d(e,n,l%8,Math.floor(l/8)).length>0&&t.push(l);return t};function f(e){return(f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function m(e,n,t){var l;return(l=function(e,n){if("object"!==f(e)||null===e)return e;var t=e[Symbol.toPrimitive];if(void 0!==t){var l=t.call(e,n||"default");if("object"!==f(l))return l;throw TypeError("@@toPrimitive must return a primitive value.")}return("string"===n?String:Number)(e)}(n,"string"),(n="symbol"===f(l)?l:String(l))in e)?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var g=function(e){var n=e.value,t=m(m({},1,"black:primary"),2,"white:primary");return s.createElement(a.Z,{sx:{borderRadius:"50%",backgroundColor:t[n],height:"100%",width:"100%"}})},E=["piece","canPlacePiece","turn"];function x(){return(x=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}var b=function(e){var n=e.piece,t=e.canPlacePiece,l=e.turn,r=function(e,n){if(null==e)return{};var t,l,r=function(e,n){if(null==e)return{};var t,l,r={},o=Object.keys(e);for(l=0;l<o.length;l++)t=o[l],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(l=0;l<o.length;l++)t=o[l],!(n.indexOf(t)>=0)&&Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}(e,E);return t?s.createElement(a.Z,x({sx:{p:"1x",cursor:"pointer",opacity:.1,_hover:{opacity:1}}},r),s.createElement(g,{value:l})):s.createElement(a.Z,x({sx:{p:"1x"}},r),s.createElement(g,{value:n}))};function v(){return(v=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}function C(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var y=function(e){var n=(0,s.useContext)(u),t=n.restart,l=n.cells,r=n.updateCells,o=n.turn,h=n.nextTurn,f=1===o?2:1,m=p(l,o),g=p(l,f),E=0===m.length&&0===g.length;return s.createElement(a.Z,v({sx:{width:"80vw",height:"80vw",maxWidth:480,maxHeight:480,backgroundImage:"linear-gradient(90deg, rgba(0, 0, 0, 0.5) 2.5%, transparent 2.5%), linear-gradient( rgba(0, 0, 0, 0.95) 2.5%, transparent 2.5%)",backgroundSize:"12.5% 12.5%",backgroundRepeat:"repeat",backgroundColor:"wheat",display:"grid",gridTemplateColumns:"repeat(8, 12.5%)",gridTemplateRows:"repeat(8, 12.5%)",position:"relative"}},e),E&&s.createElement(s.Fragment,null,s.createElement(a.Z,{sx:{position:"absolute",inset:0,backgroundColor:"black:primary",opacity:.7}}),s.createElement(i.Z,{sx:{position:"absolute",inset:0,alignItems:"center",justifyContent:"center",userSelect:"none",cursor:"pointer"},onClick:function(){t()}},s.createElement(c.Z,{color:"white:primary",fontSize:48,lineHeight:"1"},"GAME OVER"))),l.map(function(e,n){var t=n%8,a=Math.floor(n/8),i=!E&&1===o&&m.includes(n);return s.createElement(b,{key:"".concat(t,"-").concat(a),"data-coordinate-x":t,"data-coordinate-y":a,piece:e,canPlacePiece:i,turn:o,onClick:function(e){if(i){var c=function(e){if(Array.isArray(e))return C(e)}(l)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(l)||function(e,n){if(e){if("string"==typeof e)return C(e,void 0);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return C(e,void 0)}}(l)||function(){throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(),s=d(l,o,t,a);if(s.length>0){c[n]=o;for(var u=0;u<s.length;++u)c[s[u]]=o;r(c),h()}}}})}))},I=function(){var e=Array(64).fill(1),n=function(e,n){return e+8*n};e[n(0,0)]=90,e[n(7,0)]=90,e[n(0,7)]=90,e[n(7,7)]=90;for(var t=2;t<6;++t)e[n(t,0)]=10,e[n(t,7)]=10;for(var l=2;l<6;++l)e[n(0,l)]=10,e[n(7,l)]=10;return e[n(0,1)]=-20,e[n(1,0)]=-20,e[n(1,1)]=-20,e[n(6,0)]=-20,e[n(6,1)]=-20,e[n(7,1)]=-20,e[n(0,6)]=-20,e[n(1,6)]=-20,e[n(1,7)]=-20,e[n(6,6)]=-20,e[n(7,6)]=-20,e[n(6,7)]=-20,e}(),P=function(e){var n=p(e,1),t=p(e,2);if(0===n.length&&0===t.length)return(e.filter(function(e){return 1===e}).length-e.filter(function(e){return 2===e}).length)*1e4;for(var l=0,r=0,o=0;o<e.length;++o)2===e[o]&&(r+=I[o]),1===e[o]&&(l+=I[o]);return l-r+(n.length-t.length)},S=function e(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:4,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a=1===t?2:1,i=!!(l%2),c=i?-1/0:1/0,s=p(n,t);if(0===s.length)return 0===p(n,a).length?P(n):e(n,a,l+1,r,o);if(l>r)return P(n);for(var u=-1,h=0;h<s.length;h++){var f=s[h],m=d(n,t,f%8,Math.floor(f/8));if(0!==m.length){n[f]=t;for(var g=0;g<m.length;g++)n[m[g]]=t;var E=e(n,a,l+1,r,c);n[f]=0;for(var x=0;x<m.length;x++)n[m[x]]=a;if(null!==o&&i&&E>=o||null!==o&&!i&&E<=o)return E;i?c=Math.max(c,E):(0===l&&E<c&&(u=f),c=Math.min(c,E))}}return 0===l?u:c};function _(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var l,r,o,a,i=[],c=!0,s=!1;try{if(o=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;c=!1}else for(;!(c=(l=o.call(t)).done)&&(i.push(l.value),i.length!==n);c=!0);}catch(e){s=!0,r=e}finally{try{if(!c&&null!=t.return&&(a=t.return(),Object(a)!==a))return}finally{if(s)throw r}}return i}}(e,n)||A(e,n)||function(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function A(e,n){if(e){if("string"==typeof e)return B(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return B(e,n)}}function B(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var j=function(){var e=_((0,s.useState)(1),2),n=e[0],t=e[1],l=_((0,s.useState)(Array(64).fill(0)),2),r=l[0],o=l[1],h=(0,s.useCallback)(function(){t(2===n?1:2)},[n]),p=(0,s.useCallback)(function(){var e=Array(64).fill(0);e[27]=2,e[28]=1,e[35]=1,e[36]=2,o(e),t(1)},[]),f=(0,s.useMemo)(function(){return{cells:r,updateCells:o,turn:n,nextTurn:h,restart:p}},[r,o,n,h,p]);return(0,s.useEffect)(function(){p()},[p]),(0,s.useEffect)(function(){2===n&&requestAnimationFrame(function(){var e=function(e){if(Array.isArray(e))return B(e)}(r)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(r)||A(r)||function(){throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(),t=S(e,n),l=d(r,n,t%8,Math.floor(t/8));if(l.length>0){e[t]=n;for(var a=0;a<l.length;++a)e[l[a]]=n;o(e),h()}})},[n,h,r,o]),s.createElement(u.Provider,{value:f},s.createElement(a.Z,{sx:{width:"80vw",maxWidth:480,mb:"4x"}},s.createElement(i.Z,{alignItems:"center",justifyContent:"space-between"},s.createElement(c.Z,{fontSize:"xl",lineHeight:"xl"},"White: ",r.reduce(function(e,n){return 2===n?e+1:e},0)),s.createElement(c.Z,{fontSize:"xl",lineHeight:"xl"},"Black: ",r.reduce(function(e,n){return 1===n?e+1:e},0)))),s.createElement(y,null))};function T(e){var n=Object.assign({div:"div",h1:"h1",h2:"h2",a:"a",svg:"svg",use:"use",p:"p",h3:"h3",pre:"pre",code:"code",ul:"ul",li:"li",ol:"ol"},(0,r.ah)(),e.components);return(0,l.jsxs)(n.div,{className:"main-content",children:["\n","\n",(0,l.jsx)(n.h1,{id:"othello",children:"Othello"}),"\n",(0,l.jsxs)(n.h2,{id:"overview",children:["Overview",(0,l.jsx)(n.a,{"aria-hidden":!0,className:"anchor-link",tabIndex:"-1",href:"#overview",children:(0,l.jsx)(n.svg,{children:(0,l.jsx)(n.use,{xlinkHref:"#anchor-link-icon"})})})]}),"\n",(0,l.jsx)(n.p,{children:"Othello, also known as Reversi, is a strategy board game involving two players. Each player takes turns placing their pieces on an 8x8 board, aiming to have the majority of their color pieces on the board at the end of the game. The game starts with an initial configuration of two black pieces and two white pieces placed in the center of the board. Players then alternately place their pieces on the board, flipping the opponent's pieces to their own color whenever they bracket one or more of the opponent's pieces in a straight line (horizontally, vertically, or diagonally)."}),"\n",(0,l.jsx)(o.Z,Object.assign({},{component:j,file:{data:"import {\n  Box,\n  Flex,\n  Text,\n} from '@tonic-ui/react';\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport {\n  BOARD_SIZE,\n  CELL_SIZE,\n  EMPTY_PIECE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from './constants';\nimport {\n  GameStateContext,\n} from './context';\nimport {\n  getReversiblePieces,\n} from './utils';\nimport Board from './Board';\nimport { search } from './computer';\n\nconst Othello = () => {\n  const [turn, setTurn] = useState(BLACK_PIECE);\n  const [cells, updateCells] = useState((new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE));\n  const nextTurn = useCallback(() => {\n    setTurn(turn === WHITE_PIECE ? BLACK_PIECE : WHITE_PIECE);\n  }, [turn]);\n  const restart = useCallback(() => {\n    const nextCells = (new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE);\n    nextCells[BOARD_SIZE * 3 + 3] = WHITE_PIECE;\n    nextCells[BOARD_SIZE * 3 + 4] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 3] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 4] = WHITE_PIECE;\n    updateCells(nextCells);\n    setTurn(BLACK_PIECE);\n  }, []);\n  const context = useMemo(() => ({\n    cells,\n    updateCells,\n    turn,\n    nextTurn,\n    restart,\n  }), [cells, updateCells, turn, nextTurn, restart]);\n\n  // Game Start\n  useEffect(() => {\n    restart();\n  }, [restart]);\n\n  // Computer Move\n  useEffect(() => {\n    if (turn !== WHITE_PIECE) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      const nextCells = [...cells];\n      const cellId = search(nextCells, turn);\n      const x = cellId % 8;\n      const y = Math.floor(cellId / 8);\n      const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n      if (reversiblePieces.length > 0) {\n        nextCells[cellId] = turn;\n        for (let i = 0; i < reversiblePieces.length; ++i) {\n          nextCells[reversiblePieces[i]] = turn;\n        }\n        updateCells(nextCells);\n        nextTurn();\n      }\n    });\n  }, [turn, nextTurn, cells, updateCells]);\n\n  return (\n    <GameStateContext.Provider value={context}>\n      <Box\n        sx={{\n          width: '80vw',\n          maxWidth: BOARD_SIZE * CELL_SIZE,\n          mb: '4x',\n        }}\n      >\n        <Flex alignItems=\"center\" justifyContent=\"space-between\">\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            White: {cells.reduce((acc, piece) => piece === WHITE_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            Black: {cells.reduce((acc, piece) => piece === BLACK_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n        </Flex>\n      </Box>\n      <Board />\n    </GameStateContext.Provider>\n  );\n};\n\nexport default Othello;",path:"pages/playground/othello/index.page.mdx"},sandbox:{files:{"src/pages/playground/othello/othello/constants.js":"export const BOARD_SIZE = 8;\nexport const CELL_SIZE = 60;\nexport const EMPTY_PIECE = 0;\nexport const BLACK_PIECE = 1;\nexport const WHITE_PIECE = 2;","src/pages/playground/othello/othello/context.js":"import { createContext, useContext } from 'react';\n\nconst GameStateContext = createContext();\n\nconst useGameState = () => {\n  const context = useContext(GameStateContext);\n  return context;\n};\n\nexport {\n  GameStateContext,\n  useGameState,\n};","src/pages/playground/othello/othello/utils.js":"import { BOARD_SIZE, EMPTY_PIECE } from '@/pages/playground/othello/othello/constants';\n\nexport const getPiece = (cells, x, y) => cells[x + BOARD_SIZE * y];\n\nexport const getReversiblePieces = (cells, turn, x, y) => {\n  const piece = getPiece(cells, x, y);\n  if (piece !== EMPTY_PIECE) {\n    return [];\n  }\n\n  const reversiblePieces = [];\n  const opponentPieces = [];\n  const checkCell = (x, y) => {\n    const piece = getPiece(cells, x, y);\n    if (piece === EMPTY_PIECE) {\n      return false;\n    }\n    if (piece !== turn) {\n      opponentPieces.push(x + BOARD_SIZE * y);\n      return true;\n    }\n    if (piece === turn) {\n      reversiblePieces.push(...opponentPieces);\n      return false;\n    }\n    return true;\n  };\n\n  // to left\n  opponentPieces.length = 0;\n  for (let i = x - 1; i >= 0; i--) {\n    if (checkCell(i, y) === false) {\n      break;\n    }\n  }\n\n  // to right\n  opponentPieces.length = 0;\n  for (let i = x + 1; i < 8; i++) {\n    if (checkCell(i, y) === false) {\n      break;\n    }\n  }\n\n  // to top\n  opponentPieces.length = 0;\n  for (let i = y - 1; i >= 0; i--) {\n    if (checkCell(x, i) === false) {\n      break;\n    }\n  }\n\n  // to bottom\n  opponentPieces.length = 0;\n  for (let i = y + 1; i < 8; i++) {\n    if (checkCell(x, i) === false) {\n      break;\n    }\n  }\n\n  // to upper left\n  opponentPieces.length = 0;\n  for (let i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  // to upper right\n  opponentPieces.length = 0;\n  for (let i = x + 1, j = y - 1; i < 8 && j >= 0; i++, j--) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  // to bottom right\n  opponentPieces.length = 0;\n  for (let i = x + 1, j = y + 1; i < 8 && j < 8; i++, j++) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  // to bottom left\n  opponentPieces.length = 0;\n  for (let i = x - 1, j = y + 1; i >= 0 && j < 8; i--, j++) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  return reversiblePieces;\n};\n\nexport const getPlaceableCells = (cells, turn) => {\n  const placeableCells = [];\n  for (let i = 0; i < BOARD_SIZE**2; i++) {\n    const x = i % BOARD_SIZE;\n    const y = Math.floor(i / BOARD_SIZE);\n    const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n    if (reversiblePieces.length > 0) {\n      placeableCells.push(i);\n    }\n  }\n  return placeableCells;\n};","src/pages/playground/othello/othello/Board.js":"import {\n  Box,\n  Flex,\n  Text,\n} from '@tonic-ui/react';\nimport React from 'react';\nimport Cell from '@/pages/playground/othello/othello/Cell';\nimport {\n  BOARD_SIZE,\n  CELL_SIZE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from '@/pages/playground/othello/othello/constants';\nimport { \n  useGameState,\n} from '@/pages/playground/othello/othello/context';\nimport {\n  getReversiblePieces,\n  getPlaceableCells,\n} from '@/pages/playground/othello/othello/utils';\n\nconst Board = (props) => {\n  const { restart, cells, updateCells, turn, nextTurn } = useGameState();\n  const opponent = turn === BLACK_PIECE ? WHITE_PIECE : BLACK_PIECE;\n  const placeableCells = getPlaceableCells(cells, turn);\n  const opponentPlaceableCells = getPlaceableCells(cells, opponent);\n  const isGameEnd = placeableCells.length === 0 && opponentPlaceableCells.length === 0;\n\n  return (\n    <Box\n      sx={{\n        width: '80vw',\n        height: '80vw',\n        maxWidth: BOARD_SIZE * CELL_SIZE,\n        maxHeight: BOARD_SIZE * CELL_SIZE,\n        backgroundImage: 'linear-gradient(90deg, rgba(0, 0, 0, 0.5) 2.5%, transparent 2.5%), linear-gradient( rgba(0, 0, 0, 0.95) 2.5%, transparent 2.5%)',\n        backgroundSize: '12.5% 12.5%',\n        backgroundRepeat: 'repeat',\n        backgroundColor: 'wheat',\n        display: 'grid',\n        gridTemplateColumns: 'repeat(8, 12.5%)',\n        gridTemplateRows: 'repeat(8, 12.5%)',\n        position: 'relative',\n      }}\n      {...props}\n    >\n      {isGameEnd && (\n        <>\n          <Box\n            sx={{\n              position: 'absolute',\n              inset: 0,\n              backgroundColor: 'black:primary',\n              opacity: 0.7,\n            }}\n          />\n          <Flex\n            sx={{\n              position: 'absolute',\n              inset: 0,\n              alignItems: 'center',\n              justifyContent: 'center',\n              userSelect: 'none',\n              cursor: 'pointer',\n            }}\n            onClick={() => {\n              restart();\n            }}\n          >\n            <Text\n              color=\"white:primary\"\n              fontSize={48}\n              lineHeight=\"1\"\n            >\n              GAME OVER\n            </Text>\n          </Flex>\n        </>\n      )}\n      {cells.map((piece, cellId) => {\n        const x = cellId % BOARD_SIZE;\n        const y = Math.floor(cellId / BOARD_SIZE);\n        const canPlacePiece = !isGameEnd && (turn === BLACK_PIECE) && placeableCells.includes(cellId);\n        const handleClick = (e) => {\n          if (!canPlacePiece) {\n            return;\n          }\n          const nextCells = [...cells];\n          const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n          if (reversiblePieces.length > 0) {\n            nextCells[cellId] = turn;\n            for (let i = 0; i < reversiblePieces.length; ++i) {\n              nextCells[reversiblePieces[i]] = turn;\n            }\n            updateCells(nextCells);\n            nextTurn();\n          }\n        };\n\n        return (\n          <Cell\n            key={`${x}-${y}`}\n            data-coordinate-x={x}\n            data-coordinate-y={y}\n            piece={piece}\n            canPlacePiece={canPlacePiece}\n            turn={turn}\n            onClick={handleClick}\n          />\n        );\n      })}\n    </Box>\n  );\n};\n\nexport default Board;","src/pages/playground/othello/othello/Cell.js":"import {\n  Box,\n} from '@tonic-ui/react';\nimport React from 'react';\nimport Piece from '@/pages/playground/othello/othello/Piece';\n\nconst Cell = ({\n  piece,\n  canPlacePiece,\n  turn,\n  ...rest\n}) => {\n  if (canPlacePiece) {\n    return (\n      <Box\n        sx={{\n          p: '1x',\n          cursor: 'pointer',\n          opacity: 0.1,\n          _hover: {\n            opacity: 1,\n          }\n        }}\n        {...rest}\n      >\n        <Piece value={turn} />\n      </Box>\n    );\n  }\n\n  return (\n    <Box\n      sx={{\n        p: '1x',\n      }}\n      {...rest}\n    >\n      <Piece value={piece} />\n    </Box>\n  );\n};\n\nexport default Cell;","src/pages/playground/othello/othello/Piece.js":"import {\n  Box,\n} from '@tonic-ui/react';\nimport React from 'react';\nimport { BLACK_PIECE, WHITE_PIECE } from '@/pages/playground/othello/othello/constants';\n\nconst Piece = ({ value }) => {\n  const backgroundColorMap = {\n    [BLACK_PIECE]: 'black:primary',\n    [WHITE_PIECE]: 'white:primary',\n  };\n\n  return (\n    <Box\n      sx={{\n        borderRadius: '50%',\n        backgroundColor: backgroundColorMap[value],\n        height: '100%',\n        width: '100%',\n      }}\n    />\n  );\n};\n\nexport default Piece;","src/pages/playground/othello/othello/computer.js":"import {\n  BOARD_SIZE,\n  EMPTY_PIECE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from '@/pages/playground/othello/othello/constants';\nimport {\n  getReversiblePieces,\n  getPlaceableCells,\n} from '@/pages/playground/othello/othello/utils';\n\nconst MAX_DEPTH = 4;\n\nconst evaluationTable = (() => {\n  const cells = (new Array(BOARD_SIZE**2)).fill(1);\n  const toCellId = (x, y) => x + BOARD_SIZE * y;\n\n  // Four corners\n  cells[toCellId(0, 0)] = 90;\n  cells[toCellId(BOARD_SIZE - 1, 0)] = 90;\n  cells[toCellId(0, BOARD_SIZE - 1)] = 90;\n  cells[toCellId(BOARD_SIZE - 1, BOARD_SIZE - 1)] = 90;\n\n  // Four edges, excluding adjacent corners\n  for (let x = 2; x < BOARD_SIZE - 2; ++x) {\n    cells[toCellId(x, 0)] = 10;\n    cells[toCellId(x, BOARD_SIZE - 1)] = 10;\n  }\n  for (let y = 2; y < BOARD_SIZE - 2; ++y) {\n    cells[toCellId(0, y)] = 10;\n    cells[toCellId(BOARD_SIZE - 1, y)] = 10;\n  }\n\n  // Adjacent corners: top-left\n  cells[toCellId(0, 1)] = -20;\n  cells[toCellId(1, 0)] = -20;\n  cells[toCellId(1, 1)] = -20;\n  // Adjacent corners: top-right\n  cells[toCellId(BOARD_SIZE - 2, 0)] = -20;\n  cells[toCellId(BOARD_SIZE - 2, 1)] = -20;\n  cells[toCellId(BOARD_SIZE - 1, 1)] = -20;\n  // Adjacent corners: bottom-left\n  cells[toCellId(0, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(1, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(1, BOARD_SIZE - 1)] = -20;\n  // Adjacent corners: bottom-right\n  cells[toCellId(BOARD_SIZE - 2, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(BOARD_SIZE - 1, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(BOARD_SIZE - 2, BOARD_SIZE - 1)] = -20;\n\n  /*\n  for (let i = 0; i < BOARD_SIZE; ++i) {\n    console.log('##', cells.slice(BOARD_SIZE * i, BOARD_SIZE * i + BOARD_SIZE));\n  }\n  */\n\n  return cells;\n})();\n\nconst evaluate = (cells) => {\n  const p1 = getPlaceableCells(cells, BLACK_PIECE);\n  const p2 = getPlaceableCells(cells, WHITE_PIECE);\n\n  if (p1.length === 0 && p2.length === 0) {\n    // Game End\n    const blackPieces = cells.filter(cell => cell === BLACK_PIECE).length;\n    const whitePieces = cells.filter(cell => cell === WHITE_PIECE).length;\n    return (blackPieces - whitePieces) * 10000;\n  }\n\n  let blackScore = 0;\n  let whiteScore = 0;\n  for (let i = 0; i < cells.length; ++i) {\n    if (cells[i] === WHITE_PIECE) {\n      whiteScore += evaluationTable[i];\n    }\n    if (cells[i] === BLACK_PIECE) {\n      blackScore += evaluationTable[i];\n    }\n  }\n\n  // Maximum mobility\n  const mobility = p1.length - p2.length;\n\n  const score = (blackScore - whiteScore) + mobility;\n  return score;\n};\n\n// https://github.com/Jhhhha/Game-Tree\n//\n// function alphabeta(node, depth, α, β, MinMax) \n//   if depth = 0 or node is left_node\n//     return benefit of node\n//\n//   if MinMax = Max\n//     v := -∞\n//     foreach child of node\n//       v := max(v, alphabeta(child, depth - 1, α, β, FALSE)) \n//       α := max(α, v)\n//       if β ≤ α\n//         break\n//     return v\n//   else\n//     v := ∞\n//     foreach child of node\n//       v := min(v, alphabeta(child, depth - 1, α, β, TRUE))\n//       β := min(β, v)\n//       if β ≤ α\n//         break\n//     return v\nconst search = (cells, turn = WHITE_PIECE, depth = 0, maxDepth = MAX_DEPTH, alphaBeta = null) => {\n  const opponentTurn = (turn === BLACK_PIECE) ? WHITE_PIECE : BLACK_PIECE;\n  const isOddDepth = !!(depth % 2); // Search for maximum value if it's an odd-depth\n  let value = isOddDepth ? -Infinity : Infinity;\n  const placeableCells = getPlaceableCells(cells, turn);\n\n  if (placeableCells.length === 0) { // No placeable cells\n    if (getPlaceableCells(cells, opponentTurn).length === 0) {\n      // Game End\n      return evaluate(cells);\n    }\n    return search(cells, opponentTurn, depth + 1, maxDepth, alphaBeta);\n  }\n\n  if (depth > maxDepth) {\n    // Reached the maximum depth\n    return evaluate(cells);\n  }\n\n  let computedCellId = -1;\n\n  for (let i = 0; i < placeableCells.length; i++) {\n    const cellId = placeableCells[i];\n    const x = cellId % 8;\n    const y = Math.floor(cellId / 8);\n    const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n    if (reversiblePieces.length === 0) {\n      continue;\n    }\n\n    cells[cellId] = turn;\n    for (let i = 0; i < reversiblePieces.length; i++) {\n      cells[reversiblePieces[i]] = turn;\n    }\n\n    const vv = search(cells, opponentTurn, depth + 1, maxDepth, value);\n\n    cells[cellId] = EMPTY_PIECE;\n    for (let i = 0; i < reversiblePieces.length; i++) {\n      cells[reversiblePieces[i]] = opponentTurn;\n    }\n\n    // Find the maximum value for the odd-depth\n    if (alphaBeta !== null && isOddDepth && vv >= alphaBeta) {\n      // No need to search if the maximum value is already greater than the minimum value of the previous depth\n      return vv;\n    }\n\n    // Find the minimum value for the even-depth\n    if (alphaBeta !== null && !isOddDepth && vv <= alphaBeta) {\n      // No need to search if the minimum value is already smaller than the maximum value of the previous depth\n      return vv;\n    }\n\n    if (isOddDepth) {\n      value = Math.max(value, vv);\n    } else {\n      if (depth === 0 && vv < value) {\n        computedCellId = cellId;\n      }\n      value = Math.min(value, vv);\n    }\n  }\n\n  if (depth === 0) {\n    return computedCellId;\n  }\n\n  return value;\n};\n\nexport {\n  search,\n};"},raw:"import {\n  Box,\n  Flex,\n  Text,\n} from '@tonic-ui/react';\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport {\n  BOARD_SIZE,\n  CELL_SIZE,\n  EMPTY_PIECE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from '@/pages/playground/othello/othello/constants';\nimport {\n  GameStateContext,\n} from '@/pages/playground/othello/othello/context';\nimport {\n  getReversiblePieces,\n} from '@/pages/playground/othello/othello/utils';\nimport Board from '@/pages/playground/othello/othello/Board';\nimport { search } from '@/pages/playground/othello/othello/computer';\n\nconst Othello = () => {\n  const [turn, setTurn] = useState(BLACK_PIECE);\n  const [cells, updateCells] = useState((new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE));\n  const nextTurn = useCallback(() => {\n    setTurn(turn === WHITE_PIECE ? BLACK_PIECE : WHITE_PIECE);\n  }, [turn]);\n  const restart = useCallback(() => {\n    const nextCells = (new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE);\n    nextCells[BOARD_SIZE * 3 + 3] = WHITE_PIECE;\n    nextCells[BOARD_SIZE * 3 + 4] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 3] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 4] = WHITE_PIECE;\n    updateCells(nextCells);\n    setTurn(BLACK_PIECE);\n  }, []);\n  const context = useMemo(() => ({\n    cells,\n    updateCells,\n    turn,\n    nextTurn,\n    restart,\n  }), [cells, updateCells, turn, nextTurn, restart]);\n\n  // Game Start\n  useEffect(() => {\n    restart();\n  }, [restart]);\n\n  // Computer Move\n  useEffect(() => {\n    if (turn !== WHITE_PIECE) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      const nextCells = [...cells];\n      const cellId = search(nextCells, turn);\n      const x = cellId % 8;\n      const y = Math.floor(cellId / 8);\n      const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n      if (reversiblePieces.length > 0) {\n        nextCells[cellId] = turn;\n        for (let i = 0; i < reversiblePieces.length; ++i) {\n          nextCells[reversiblePieces[i]] = turn;\n        }\n        updateCells(nextCells);\n        nextTurn();\n      }\n    });\n  }, [turn, nextTurn, cells, updateCells]);\n\n  return (\n    <GameStateContext.Provider value={context}>\n      <Box\n        sx={{\n          width: '80vw',\n          maxWidth: BOARD_SIZE * CELL_SIZE,\n          mb: '4x',\n        }}\n      >\n        <Flex alignItems=\"center\" justifyContent=\"space-between\">\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            White: {cells.reduce((acc, piece) => piece === WHITE_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            Black: {cells.reduce((acc, piece) => piece === BLACK_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n        </Flex>\n      </Box>\n      <Board />\n    </GameStateContext.Provider>\n  );\n};\n\nexport default Othello;",title:"Tonic UI"}})),"\n",(0,l.jsxs)(n.h2,{id:"game-tree",children:["Game Tree",(0,l.jsx)(n.a,{"aria-hidden":!0,className:"anchor-link",tabIndex:"-1",href:"#game-tree",children:(0,l.jsx)(n.svg,{children:(0,l.jsx)(n.use,{xlinkHref:"#anchor-link-icon"})})})]}),"\n",(0,l.jsx)(n.p,{children:"The provided algorithm is designed to create an AI that can play Othello by evaluating potential moves and selecting the best one based on a set of criteria. This process involves several key components: board evaluation, move generation, and a search function utilizing the minimax algorithm with alpha-beta pruning. Let's explore each component in detail."}),"\n",(0,l.jsxs)(n.h3,{id:"board-evaluation-function",children:["Board Evaluation Function",(0,l.jsx)(n.a,{"aria-hidden":!0,className:"anchor-link",tabIndex:"-1",href:"#board-evaluation-function",children:(0,l.jsx)(n.svg,{children:(0,l.jsx)(n.use,{xlinkHref:"#anchor-link-icon"})})})]}),"\n",(0,l.jsx)(n.p,{children:"The evaluation table assigns values to each cell on the board based on strategic importance. In the Othello game, corners and edges are highly valued, while cells adjacent to corners are penalized."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"|  90  | -20  |  10  |  10  |  10  |  10  | -20  |  90  |\n| -20  | -20  |  1   |  1   |  1   |  1   | -20  | -20  |\n|  10  |  1   |  1   |  1   |  1   |  1   |  1   |  10  |\n|  10  |  1   |  1   |  1   |  1   |  1   |  1   |  10  |\n|  10  |  1   |  1   |  1   |  1   |  1   |  1   |  10  |\n|  10  |  1   |  1   |  1   |  1   |  1   |  1   |  10  |\n| -20  | -20  |  1   |  1   |  1   |  1   | -20  | -20  |\n|  90  | -20  |  10  |  10  |  10  |  10  | -20  |  90  |\n"})}),"\n",(0,l.jsx)(n.p,{children:"The evaluation function is crucial in the Minimax algorithm with limited depth. It provides a heuristic value for each board state, allowing the algorithm to estimate the desirability of a position without exploring the entire game tree. This function considers various factors such as:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Piece Count: The number of pieces each player has on the board."}),"\n",(0,l.jsx)(n.li,{children:"Positional Advantage: The strategic value of pieces based on their positions."}),"\n",(0,l.jsx)(n.li,{children:"Mobility: The number of possible moves available to each player."}),"\n",(0,l.jsx)(n.li,{children:"Stability: The likelihood that pieces will remain unflipped for the rest of the game."}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const evaluate = (cells) => {\n  const p1 = getPlaceableCells(cells, BLACK_PIECE);\n  const p2 = getPlaceableCells(cells, WHITE_PIECE);\n\n  if (p1.length === 0 && p2.length === 0) {\n    // Game End\n    const blackPieces = cells.filter(cell => cell === BLACK_PIECE).length;\n    const whitePieces = cells.filter(cell => cell === WHITE_PIECE).length;\n    return (blackPieces - whitePieces) * 10000;\n  }\n\n  let blackScore = 0;\n  let whiteScore = 0;\n  for (let i = 0; i < cells.length; ++i) {\n    if (cells[i] === WHITE_PIECE) {\n      whiteScore += evaluationTable[i];\n    }\n    if (cells[i] === BLACK_PIECE) {\n      blackScore += evaluationTable[i];\n    }\n  }\n\n  // Maximum mobility\n  const mobility = p1.length - p2.length;\n\n  const score = (blackScore - whiteScore) + mobility;\n  return score;\n};\n"})}),"\n",(0,l.jsxs)(n.h3,{id:"minimax-algorithm",children:["Minimax algorithm",(0,l.jsx)(n.a,{"aria-hidden":!0,className:"anchor-link",tabIndex:"-1",href:"#minimax-algorithm",children:(0,l.jsx)(n.svg,{children:(0,l.jsx)(n.use,{xlinkHref:"#anchor-link-icon"})})})]}),"\n",(0,l.jsx)(n.p,{children:"Building a game tree involves starting from a particular game state and recursively adding all possible future game states as child nodes. This process continues for each child node until the game ends (a win or a loss is determined). The Minimax algorithm works by evaluating all possible end states of the game tree. For each parent node, the algorithm identifies the optimal move based on its child nodes' states. This process iterates back to the initial game state, allowing the player in that state to make the best possible move."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"function minimax(node, depth)\n    if node is a terminal node or depth = 0\n        return the heuristic value of node\n    if the adversary is to play at node\n        let α := +∞\n        foreach child of node\n            α := min(α, minimax(child, depth-1))\n    else {we are to play at node}\n        let α := -∞\n        foreach child of node\n            α := max(α, minimax(child, depth-1))\n    return α\n"})}),"\n",(0,l.jsxs)(n.h3,{id:"alpha-beta-pruning",children:["Alpha-Beta Pruning",(0,l.jsx)(n.a,{"aria-hidden":!0,className:"anchor-link",tabIndex:"-1",href:"#alpha-beta-pruning",children:(0,l.jsx)(n.svg,{children:(0,l.jsx)(n.use,{xlinkHref:"#anchor-link-icon"})})})]}),"\n",(0,l.jsx)(n.p,{children:"Alpha-Beta pruning enhances the efficiency of the Minimax algorithm by eliminating branches that do not need to be explored. This focuses the search on potentially optimal subtrees, reducing the time spent on less promising branches."}),"\n",(0,l.jsx)(n.p,{children:"Process of Alpha-Beta Pruning"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Initialization: Start from an initial game state and initialize two variables, alpha and beta, representing the best already explored option along the path to the root for the maximizer and minimizer, respectively."}),"\n",(0,l.jsx)(n.li,{children:"Value Passing: These alpha and beta values are passed down to the child nodes. Each child node updates its alpha and beta values based on the results from its own child nodes."}),"\n",(0,l.jsx)(n.li,{children:"Terminal Node: When a terminal node is reached, the result updates the alpha or beta values of the parent node. This process continues upwards through the tree."}),"\n",(0,l.jsx)(n.li,{children:"Pruning Condition: If, during exploration, we find that a game node's value exceeds the alpha or beta threshold (i.e., α >= β), we prune the remaining unexplored child nodes of that game node."}),"\n",(0,l.jsx)(n.li,{children:"Result Propagation: The recorded action and evaluation value are then passed up the tree, ultimately reaching the initial game state. This allows the player to make the best possible move from the starting position."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Alpha-Beta pruning does not affect the final result of the Minimax algorithm but significantly reduces the number of nodes to be explored. This ensures that the search time is utilized efficiently on branches that are more likely to lead to an optimal solution. By combining the evaluation function and Alpha-Beta pruning, the algorithm can make intelligent decisions within a reasonable amount of time."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"function alphabeta(node, depth, α, β, MinMax)\n    if depth = 0 or node is left_node\n        return benefit of node\n    if MinMax = Max\n        v := -∞\n        foreach child of node\n            v := max(v, alphabeta(child, depth - 1, α, β, FALSE))\n            α := max(α, v)\n            if β ≤ α\n                break\n        return v\n    else\n        v := ∞\n        foreach child of node\n            v := min(v, alphabeta(child, depth - 1, α, β, TRUE))\n            β := min(β, v)\n            if β ≤ α\n                break\n        return v\n"})})]})}var k=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=Object.assign({},(0,r.ah)(),e.components).wrapper;return n?(0,l.jsx)(n,Object.assign({},e,{children:(0,l.jsx)(T,e)})):T(e)}},96835:function(e,n,t){"use strict";t.d(n,{Z:function(){return j}});var l=t(27216),r=t(40596),o=t(49857),a=t(73645),i=t(99870),c=t(62272),s=t(14594),u=t(65019),h=t(37384),d=t(99554),p=t(69111),f=t(5632),m=t(2784),g=t(65245);function E(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var x=function(e){var n=document.createElement("textarea");n.value=e,n.setAttribute("readonly",""),n.style.position="absolute",n.style.left="-9999px",document.body.appendChild(n);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);n.select(),document.execCommand("copy"),document.body.removeChild(n),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))},b=function(e){var n,t=function(e){if(Array.isArray(e))return e}(n=(0,m.useState)(!1))||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var l,r,o,a,i=[],c=!0,s=!1;try{for(o=(t=t.call(e)).next;!(c=(l=o.call(t)).done)&&(i.push(l.value),2!==i.length);c=!0);}catch(e){s=!0,r=e}finally{try{if(!c&&null!=t.return&&(a=t.return(),Object(a)!==a))return}finally{if(s)throw r}}return i}}(n,2)||function(e,n){if(e){if("string"==typeof e)return E(e,2);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return E(e,2)}}(n,2)||function(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(),l=t[0],r=t[1];return{value:e,onCopy:function(){x(e),r(!0),setTimeout(function(){return r(!1)},1500)},hasCopied:l}},v=t(63768),C=t(76761),y=t(73205),I=t(98107),P=t(44285),S=["component","defaultExpanded","expanded","file","sandbox"];function _(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var l,r,o,a,i=[],c=!0,s=!1;try{if(o=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;c=!1}else for(;!(c=(l=o.call(t)).done)&&(i.push(l.value),i.length!==n);c=!0);}catch(e){s=!0,r=e}finally{try{if(!c&&null!=t.return&&(a=t.return(),Object(a)!==a))return}finally{if(s)throw r}}return i}}(e,n)||function(e,n){if(e){if("string"==typeof e)return A(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return A(e,n)}}(e,n)||function(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function A(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var B=function(e){var n,t=e.component,E=e.defaultExpanded,x=e.expanded,A=e.file,B=e.sandbox;!function(e,n){if(null!=e){var t,l,r=function(e,n){if(null==e)return{};var t,l,r={},o=Object.keys(e);for(l=0;l<o.length;l++)t=o[l],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(l=0;l<o.length;l++)t=o[l],!(n.indexOf(t)>=0)&&Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}}}(e,S);var j=(0,f.useRouter)(),T=_((0,m.useReducer)(function(e){return!e},!1),2),k=T[0],O=T[1],Z=(0,l.u)(),w=_((0,r.Z)(),1)[0],R={dark:C.y,light:C.q}[w],D=_((0,u.Z)(null!=x?x:void 0!==E&&E),2),M=D[0],L=D[1],H=b(null==A?void 0:A.data),W=H.onCopy,K=H.hasCopied,z=(0,m.useCallback)(function(){W()},[W]),G=(0,m.useCallback)(function(){(0,y.b)(B)},[B]),F=(0,m.useCallback)(function(){O(),L(!1)},[O,L]);return((0,m.useEffect)(function(){void 0!==x&&x!==M&&L(x)},[x,M,L]),t)?m.createElement(g.nu,{code:null==A?void 0:A.data,disabled:!0,language:"jsx",theme:R},m.createElement(o.Z,{border:1,borderColor:{dark:"gray:70",light:"gray:30"}[w],p:"4x"},m.createElement(o.Z,{fontSize:"sm",lineHeight:"sm"},m.createElement(m.Fragment,{key:k},m.createElement(t,null)))),m.createElement(a.Z,{columnGap:"2x",justifyContent:"flex-end",mb:"4x"},m.createElement(P.Z,{"data-track":M?"CodeBlock|hide_source|".concat((0,I.Z)({path:j.pathname})):"CodeBlock|show_source|".concat((0,I.Z)({path:j.pathname})),onClick:L},m.createElement(i.Z,{label:M?"Hide the source":"Show the source"},m.createElement(h.Z,null))),m.createElement(P.Z,{"data-track":"CodeBlock|copy_source|".concat((0,I.Z)({path:j.pathname})),onClick:z},m.createElement(i.Z,{label:K?"Copied":"Copy the source"},m.createElement(d.Z,null))),m.createElement(P.Z,{"data-track":"CodeBlock|edit_in_codesandbox|".concat(j.pathname),onClick:G},m.createElement(i.Z,{label:"Edit in CodeSandbox"},m.createElement(v.Z,null))),m.createElement(P.Z,{"data-track":"CodeBlock|reset|".concat(j.pathname),onClick:F},m.createElement(i.Z,{label:"Reset the demo"},m.createElement(p.Z,null)))),m.createElement(c.Z,{in:M},m.createElement(s.Z,{in:M,unmountOnExit:!0},m.createElement(o.Z,{as:g.uz,sx:{fontFamily:"mono",fontSize:"md",lineHeight:"md",mb:"4x","& > .prism-code":{padding:"".concat(null==Z?void 0:null===(n=Z.space)||void 0===n?void 0:n["4x"]," !important"),overflowX:"auto"}}})))):m.createElement(g.nu,{code:null==A?void 0:A.data,disabled:!0,language:"jsx",theme:R},m.createElement(o.Z,{as:g.uz,sx:{fontFamily:"mono",fontSize:"sm","& > .prism-code":{overflowX:"auto"}}}))};B.displayName="Demo";var j=B},34418:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/playground/othello",function(){return t(57694)}])},99554:function(e,n,t){"use strict";t.d(n,{Z:function(){return o}}),t(2784);var l=t(75928),r=t(52903),o=(0,l.Z)((0,r.tZ)("path",{d:"M12 0h-6c-0.5 0-1 0.5-1 1v3h-3c-0.5 0-1 0.5-1 1v10c0 0.5 0.5 1 1 1h8c0.5 0 1-0.5 1-1v-3h3c0.5 0 1-0.5 1-1v-8l-3-3zM12 1.4l1.6 1.6h-1.6v-1.6zM10 15h-8v-10h5v3h3v7zM8 7v-1.6l1.6 1.6h-1.6zM14 11h-3v-4l-3-3h-2v-3h5v3h3v7z"}),"FileCopyOIcon")},69111:function(e,n,t){"use strict";t.d(n,{Z:function(){return o}}),t(2784);var l=t(75928),r=t(52903),o=(0,l.Z)((0,r.tZ)("path",{d:"M10 7l1.995-1.995c-0.921-1.215-2.365-1.992-3.99-1.992-2.758 0-4.993 2.235-4.993 4.993s2.235 4.993 4.993 4.993c1.839 0 3.446-0.995 4.313-2.475l0.013-0.024 1.732 1c-1.233 2.111-3.487 3.507-6.068 3.507-3.867 0-7.003-3.135-7.003-7.003s3.135-7.003 7.003-7.003c2.183 0 4.133 0.999 5.417 2.565l0.010 0.012 1.579-1.579v5z"}),"RedoIcon")}},function(e){e.O(0,[2888,9774,179],function(){return e(e.s=34418)}),_N_E=e.O()}]);